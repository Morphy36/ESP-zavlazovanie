substitutions:
  # --- NASTAVENIA ZARIADENIA ---
  dev_name: "vonkajsia-stanica"
  friendly_name: "Vonkajšia Meteostanica"
  
  # Tvoja nadmorská výška (pre prepočet tlaku na hladinu mora)
  altitude_meters: "250" 
  
  # Limity batérie (kalibrácia podľa tvojho deliča)
  # Ak máš delič 1:1 (100k/100k), multiply je 2.0
  batt_multiplier: "2.0"
  batt_min_voltage: "3.0"
  batt_max_voltage: "4.2"

  # Časy spánku (Adaptívny režim)
  sleep_storm_mode: "2min"   # Keď prší alebo fúka
  sleep_normal_mode: "10min" # Bežný stav
  sleep_eco_mode: "30min"    # Keď je slabá batéria
  sleep_failsafe: "4min"     # Maximálny čas behu, potom sa vypne natvrdo

esphome:
  name: ${dev_name}
  friendly_name: ${friendly_name}
  
  # --- BOOT SEQUENCIA ---
  on_boot:
    priority: 1000
    then:
      # 1. Spustenie bezpečnostného časovača (Failsafe)
      - script.execute: failsafe_guard
      
      # 2. Zapnutie senzorov
      - logger.log: "ON_BOOT: Zapínam napájanie senzorov..."
      - output.turn_on: rain_sensor_power
      - output.turn_on: i2c_sensor_power
      - delay: 500ms # Krátky čas na ustálenie napätia
      
      # 3. Kontrola BME280 (I2C)
      - lambda: |-
          auto bus = id(busa);
          if (bus->write(0x76, nullptr, 0) != esphome::i2c::ERROR_OK) {
            ESP_LOGE("boot", "BME280 nenájdený! Reštartujem I2C napájanie.");
            id(restart_i2c_sensors).execute();
          } else {
            ESP_LOGI("boot", "BME280 OK.");
          }
      
      # 4. Prvé čítanie (aby sme mali dáta pre rozhodovanie)
      - delay: 100ms
      - component.update: bme280_sensor
      - component.update: battery_voltage
      
      # 5. Spustenie Wi-Fi logiky
      - script.execute: wifi_connect_logic

  on_shutdown:
    then:
      - logger.log: "SHUTDOWN: Uspávam LTR390 a vypínam piny."
      - script.execute: uspat_ltr390
      - output.turn_off: rain_sensor_power
      - output.turn_off: i2c_sensor_power

esp32:
  board: esp32dev
  framework:
    type: arduino

# --- WI-FI & API ---
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  
  # Optimalizácia pre batériu
  power_save_mode: light
  fast_connect: true        # Pamätá si BSSID, rýchlejšie pripojenie
  output_power: 8.5dBm      # Zníženie výkonu (ak máš zlý signál, vymaž tento riadok)
  
  ap:
    ssid: "Meteo Stanica AP"
    password: "esp32admin"
    ap_timeout: 1min

  on_connect:
    then:
      - logger.log: "Wi-Fi pripojené. Čakám na odoslanie dát..."

api:
  id: api_server
  reboot_timeout: 0s
  # Dôležité: Neuspávať, kým je pripojený Home Assistant (servisný mód)
  on_client_connected:
    then:
      - logger.log: "API klient pripojený -> Blokujem Deep Sleep."
      - deep_sleep.prevent: deep_sleep_control
      - script.stop: failsafe_guard # Zastavíme failsafe, lebo sme v servise
  on_client_disconnected:
    then:
      - logger.log: "API klient odpojený -> Povoľujem Deep Sleep."
      - deep_sleep.allow: deep_sleep_control
      - script.execute: check_and_enter_deep_sleep

ota:
  platform: esphome
  password: "baca332b9259e0fcba761b48e90ff1cb"

logger:
  level: INFO
  baud_rate: 115200

debug:

web_server:
  port: 80
  ota: false

# --- HARDWARE ---
i2c:
  sda: GPIO22
  scl: GPIO21
  scan: false # Vypnuté pre rýchlejší boot
  id: busa
  frequency: 100kHz
  timeout: 50ms

# --- GLOBÁLNE PREMENNÉ (Pamäť medzi spánkom) ---
globals:
  - id: pressure_history
    type: float[6]
    restore_value: true # Dôležité: Zachovať históriu
    initial_value: "{NAN, NAN, NAN, NAN, NAN, NAN}"
  - id: history_index
    type: int
    restore_value: true
    initial_value: "0"
  - id: prev_humidity
    type: float
    restore_value: true
    initial_value: "NAN"
  - id: pressure_threshold
    type: float
    restore_value: true
    initial_value: "-0.3"
  - id: humidity_threshold
    type: float
    restore_value: true
    initial_value: "80.0"
  - id: i2c_restart_attempts
    type: int
    restore_value: false
    initial_value: "0"

# --- SENZORY (Hardware) ---
sensor:
  # 1. BME280 (Teplota, Tlak, Vlhkosť)
  - platform: bme280_i2c
    address: 0x76
    i2c_id: busa
    id: bme280_sensor
    update_interval: 15s
    temperature:
      name: "Vonkajšia Teplota"
      id: bme280_temperature
      oversampling: 4x
    pressure:
      name: "Absolútny tlak"
      id: bme280_pressure
      oversampling: 4x
      # Prepočet na MSL (Hladinu mora)
      on_value:
        then:
          - lambda: |-
              float h = ${altitude_meters}; 
              float t = id(bme280_temperature).state;
              float msl = x * pow(1.0 - (0.0065 * h) / (t + 0.0065 * h + 273.15), -5.257);
              id(msl_pressure).publish_state(msl);
    humidity:
      name: "Vonkajšia Vlhkosť"
      id: bme280_humidity
      oversampling: 4x

  # 2. LTR390 (Svetlo, UV)
  - platform: ltr390
    address: 0x53
    i2c_id: busa
    id: ltr390_sensor
    update_interval: 15s
    light:
      name: "Intenzita svetla"
      id: ambient_light
    uv:
      name: "UV Index (RAW)"
      id: uv_raw_data
      internal: true

  # 3. Batéria (ADC)
  - platform: adc
    pin: GPIO35
    name: "Napätie batérie"
    id: battery_voltage
    update_interval: 60s
    attenuation: 12db
    accuracy_decimals: 2
    filters:
      - multiply: ${batt_multiplier}
      - sliding_window_moving_average: { window_size: 5, send_every: 1 }

  # 4. Dažďový senzor (Analógová vlhkosť)
  - platform: adc
    pin: GPIO34
    id: rain_sensor_voltage
    name: "Napätie dažďového senzora"
    entity_category: diagnostic
    update_interval: 10s
    attenuation: 12db

  - platform: template
    name: "Vlhkosť dažďového senzora"
    id: rain_sensor_percent
    unit_of_measurement: "%"
    icon: "mdi:water-percent"
    lambda: |-
      if (id(rain_sensor_voltage).has_state()) {
        // Kalibrácia: 1.033V (sucho) -> 0.419V (mokro)
        float val = map(id(rain_sensor_voltage).state, 1.033f, 0.419f, 0.0f, 100.0f);
        return clamp(val, 0.0f, 100.0f);
      }
      return NAN;
    update_interval: 10s

  # 5. Anemometer (Vietor) - HARDWARE PCNT
  - platform: pulse_counter
    pin:
      number: GPIO25
      mode: INPUT_PULLUP
    name: "Rýchlosť vetra (Priemer)"
    id: wind_speed
    unit_of_measurement: "km/h"
    update_interval: 5s
    use_pcnt: true # Použije hardvérové počítadlo ESP32
    filters:
      # 1 otáčka/s = 2.4 km/h. PulseCounter vracia pulzy/minútu.
      # (pulzy_za_min / 60) * 2.4 = pulzy_za_min * 0.04
      - multiply: 0.04 

  - platform: copy
    source_id: wind_speed
    name: "Rýchlosť vetra (Náraz/Gust)"
    id: wind_gust
    # update_interval: 5s  <-- TENTO RIADOK MUSÍŠ VYMAZAŤ!
    filters:
      - multiply: 0.04
      # DÔLEŽITÁ ÚPRAVA PRE BATÉRIU:
      # Pôvodné nastavenie čakalo na 5 meraní (5x5s = 25 sekúnd), kým poslalo prvú hodnotu.
      # To by zdržiavalo uspanie stanice. Zmenil som to tak, aby poslalo hodnotu hneď.
      - max: 
          window_size: 5
          send_every: 1     # Pošli update pri každom novom meraní
          send_first_at: 1  # Nečakaj na naplnenie okna, pošli hneď prvú hodnotu

  # 6. Zrážkomer (Kýblik) - HARDWARE PCNT
  - platform: pulse_counter
    pin:
      number: GPIO26
      mode: INPUT_PULLUP
    name: "Intenzita zrážok"
    id: rain_fall_rate
    unit_of_measurement: "mm/h"
    update_interval: 60s
    use_pcnt: true
    filters:
      # 1 pulz = 0.2794 mm. PulseCounter vracia pulzy/min.
      # mm/h = pulzy_za_min * 60 * 0.2794
      - multiply: 16.764 
    total:
      name: "Celkové zrážky"
      unit_of_measurement: "mm"
      accuracy_decimals: 2
      filters:
        - multiply: 0.2794

  # 7. Smer vetra (ADC + Výpočet)
  - platform: adc
    pin: GPIO33
    id: wind_vane_voltage
    name: "Napätie smeru vetra"
    internal: true
    update_interval: 10s
    attenuation: 12db

  - platform: template
    name: "Smer vetra (Uhol)"
    id: wind_direction_angle
    unit_of_measurement: "°"
    icon: "mdi:compass-rose"
    lambda: |-
      if (!id(wind_vane_voltage).has_state()) return NAN;
      float v = id(wind_vane_voltage).state;
      if (v < 0.05f) return 0.0f; // Ochrana delenia nulou
      
      // Výpočet odporu (predpoklad 10k pullup na 3.3V)
      float r_vane = 10000.0f * ((3.3f / v) - 1.0f);
      
      // Tabuľka hodnôt (Uhol vs Odpor)
      const float angles[] = {0, 22.5, 45, 67.5, 90, 112.5, 135, 157.5, 180, 202.5, 225, 247.5, 270, 292.5, 315, 337.5};
      const float res[] = {33000, 6570, 8200, 891, 1000, 688, 2200, 1410, 3900, 3140, 16000, 14120, 120000, 42120, 64900, 21880};
      
      float min_diff = 1000000.0f;
      float best_angle = 0.0f;
      
      for (int i=0; i<16; i++) {
        float diff = abs(r_vane - res[i]);
        if (diff < min_diff) { min_diff = diff; best_angle = angles[i]; }
      }
      return best_angle;

  # --- Vypočítané senzory ---
  
  - platform: template
    name: "Tlak (Hladina mora)"
    id: msl_pressure
    unit_of_measurement: "hPa"
    accuracy_decimals: 1
    icon: "mdi:gauge"

  - platform: template
    name: "Rosný bod"
    id: dew_point
    unit_of_measurement: "°C"
    icon: "mdi:thermometer-water"
    lambda: |-
      if (!id(bme280_temperature).has_state() || !id(bme280_humidity).has_state()) return NAN;
      float T = id(bme280_temperature).state;
      float RH = id(bme280_humidity).state;
      float a = 17.27; float b = 237.7;
      float alpha = ((a * T) / (b + T)) + log(RH / 100.0);
      return (b * alpha) / (a - alpha);

  - platform: template
    name: "Pocitová teplota"
    id: feels_like_temp
    unit_of_measurement: "°C"
    icon: "mdi:thermometer-lines"
    lambda: |-
      if (!id(bme280_temperature).has_state() || !id(bme280_humidity).has_state() || !id(wind_speed).has_state()) return NAN;
      float t = id(bme280_temperature).state;
      float h = id(bme280_humidity).state;
      float v = id(wind_speed).state;
      
      // Wind Chill (Zima)
      if (t <= 10.0 && v >= 4.8) {
        return 13.12 + (0.6215 * t) - (11.37 * pow(v, 0.16)) + (0.3965 * t * pow(v, 0.16));
      }
      // Heat Index (Leto) - zjednodušene nad 26°C
      if (t >= 26.0) { 
         return -8.78 + 1.61*t + 2.33*h - 0.146*t*h - 0.012*t*t - 0.016*h*h + 0.002*t*t*h + 0.0007*t*h*h - 0.000003*t*t*h*h;
      }
      return t;

  - platform: template
    name: "UV Index"
    id: uv_index_calc
    unit_of_measurement: "UVI"
    accuracy_decimals: 1
    lambda: |-
      if (id(uv_raw_data).has_state()) {
        return id(uv_raw_data).state / 170.0f; // Konverzný faktor pre LTR390
      }
      return NAN;

  - platform: template
    name: "Úroveň batérie"
    id: battery_level
    unit_of_measurement: "%"
    device_class: battery
    lambda: |-
      if (!id(battery_voltage).has_state()) return NAN;
      float v = id(battery_voltage).state;
      float min = ${batt_min_voltage};
      float max = ${batt_max_voltage};
      return clamp((v - min) / (max - min) * 100.0f, 0.0f, 100.0f);

  # Diagnostika
  - platform: internal_temperature
    name: "Teplota CPU"
    entity_category: diagnostic
  
  - platform: uptime
    name: "Čas behu"
    id: uptime_sensor
    update_interval: 1s
    entity_category: diagnostic

  - platform: wifi_signal
    name: "WiFi Signál dBm"
    id: wifi_signal_dbm
    update_interval: 60s
    entity_category: diagnostic

  - platform: copy
    source_id: wifi_signal_dbm
    name: "Kvalita WiFi"
    unit_of_measurement: "%"
    filters:
      - lambda: |-
          if (x <= -100.0) return 0.0;
          if (x >= -50.0) return 100.0;
          return 2.0 * (x + 100.0);

# --- BINÁRNE SENZORY ---
binary_sensor:
  - platform: status
    name: "Status Stanice"

  - platform: template
    name: "Detekcia dažďa"
    id: rain_detection
    device_class: moisture
    lambda: |-
      auto s = id(rain_sensor_percent);
      return s && s->has_state() && s->state > 10.0f; // >10% vlhkosť = dážď
    filters:
      - delayed_on: 5s
      - delayed_off: 5s

  - platform: template
    name: "Kritická batéria"
    id: low_battery
    device_class: battery
    lambda: |-
      auto s = id(battery_voltage);
      if (!s || !s->has_state()) return false;
      return s->state < (${batt_min_voltage} + 0.1); 

  - platform: template
    name: "Predikcia dažďa (Tlak)"
    id: rain_prediction
    lambda: |-
      auto p = id(bme280_pressure);
      auto h = id(bme280_humidity);
      if (!p || !p->has_state() || !h || !h->has_state()) return false;

      float cur_p = p->state;
      float hum = h->state;

      // Zápis do histórie
      id(pressure_history)[id(history_index)] = cur_p;
      id(history_index) = (id(history_index) + 1) % 6;

      int valid = 0; float sum = 0.0f;
      for (int i = 0; i < 6; i++) {
        if (!isnan(id(pressure_history)[i]) && id(pressure_history)[i] > 800) { 
          sum += id(pressure_history)[i]; valid++; 
        }
      }
      
      // Potrebujeme aspoň 2 vzorky (z rôznych cyklov spánku)
      if (valid < 2) return false; 
      
      float avg = sum / valid;
      float dP = cur_p - avg;
      bool hum_rising = (!isnan(id(prev_humidity)) && hum > id(prev_humidity));
      id(prev_humidity) = hum;

      // Logika predpovede
      if (dP < id(pressure_threshold) && cur_p < avg && hum_rising) return true;
      if (cur_p < 1000.0f && hum > id(humidity_threshold)) return true;
      
      return false;

# --- TEXTOVÉ SENZORY (UI) ---
text_sensor:
  - platform: template
    name: "Odporúčanie oblečenia"
    icon: mdi:hanger
    update_interval: 60s
    lambda: |-
      if (!id(bme280_temperature).has_state()) return std::string("Načítavam...");
      float t = id(bme280_temperature).state;
      bool rain = id(rain_prediction).state || id(rain_detection).state;

      if (rain) {
        if (t < 10) return std::string("Prší a je zima. Zimná bunda + dáždnik.");
        if (t < 20) return std::string("Prší. Nepremokavá bunda.");
        return std::string("Búrka z tepla? Vezmi dáždnik.");
      }
      if (t < 5) return std::string("Mráz! Zimná bunda, čiapka, rukavice.");
      if (t < 15) return std::string("Chladno. Sveter a bunda.");
      if (t < 22) return std::string("Príjemne. Mikina alebo tričko.");
      if (t > 30) return std::string("Horúčava! Obleč sa naľahko.");
      return std::string("Ideálne počasie.");

  - platform: template
    name: "Smer vetra (Text)"
    id: wind_dir_text
    update_interval: 10s
    lambda: |-
      if (!id(wind_direction_angle).has_state()) return std::string("N/A");
      const char* dirs[] = {"S (N)", "SSV (NNE)", "SV (NE)", "VSV (ENE)", "V (E)", "VJV (ESE)", "JV (SE)", "JJV (SSE)", "J (S)", "JJZ (SSW)", "JZ (SW)", "ZJZ (WSW)", "Z (W)", "ZSZ (WNW)", "SZ (NW)", "SSZ (NNW)"};
      int idx = (int)((id(wind_direction_angle).state + 11.25f) / 22.5f) % 16;
      return std::string(dirs[idx]);
      
  - platform: debug
    reset_reason:
      name: "Dôvod reštartu"
      entity_category: diagnostic

# --- OUTPUTS & SWITCHES ---
output:
  - platform: gpio
    pin: GPIO18
    id: rain_sensor_power
  - platform: gpio
    pin: GPIO19
    id: i2c_sensor_power

switch:
  - platform: template
    name: "Manuálne napájanie senzorov"
    optimistic: true
    turn_on_action:
      - output.turn_on: rain_sensor_power
      - output.turn_on: i2c_sensor_power
    turn_off_action:
      - output.turn_off: rain_sensor_power
      - output.turn_off: i2c_sensor_power

  - platform: template
    name: "Vynútiť Deep Sleep"
    icon: mdi:sleep
    turn_on_action:
      - deep_sleep.enter: deep_sleep_control

  - platform: restart
    name: "Reštartovať Stanicu"

deep_sleep:
  id: deep_sleep_control
  # Trvanie sa nastavuje dynamicky v skripte

# --- SKRIPTY (LOGIKA) ---
script:
  # 1. Failsafe: Ak sa stanica zasekne, toto ju vypne po 4 minútach
  - id: failsafe_guard
    then:
      - delay: ${sleep_failsafe}
      - logger.log: "FAILSAFE: Čas vypršal! Núdzový spánok."
      - output.turn_off: rain_sensor_power
      - output.turn_off: i2c_sensor_power
      - deep_sleep.enter:
          id: deep_sleep_control
          sleep_duration: 10min

  # 2. Wi-Fi pripojenie
  - id: wifi_connect_logic
    then:
      - wait_until:
          condition: wifi.connected
          timeout: 45s
      - if:
          condition: wifi.connected
          then:
             - logger.log: "Wi-Fi OK."
          else:
             - logger.log: "Wi-Fi zlyhalo. Idem spať (Offline)."
             - deep_sleep.enter:
                 id: deep_sleep_control
                 sleep_duration: 5min

  # 3. Uspatie LTR390 (vyžaduje I2C príkaz)
  - id: uspat_ltr390
    then:
      - lambda: |-
          auto bus = id(busa);
          if (bus) { uint8_t cmd[] = {0x00, 0x00}; bus->write(0x53, cmd, 2); }

  # 4. Reštart senzorov pri chybe
  - id: restart_i2c_sensors
    mode: restart
    then:
      - lambda: 'id(i2c_restart_attempts) += 1;'
      - output.turn_off: i2c_sensor_power
      - delay: 500ms
      - output.turn_on: i2c_sensor_power
      - delay: 1s
      - if:
          condition:
            lambda: 'return id(i2c_restart_attempts) >= 3;'
          then:
             - logger.log: "I2C Senzory sú mŕtve. Vzdávam to."
          else:
             - component.update: bme280_sensor

  # 5. HLAVNÝ MOZOG: Rozhodnutie o spánku (Adaptívny Deep Sleep)
  - id: check_and_enter_deep_sleep
    then:
      - if:
          condition:
            and:
              - wifi.connected:
              - lambda: 'return id(bme280_temperature).has_state();'
          then:
            # Aktualizácia stavov pre istotu
            - component.update: battery_level
            - delay: 100ms
            
            - lambda: |-
                float bat = id(battery_level).has_state() ? id(battery_level).state : 50.0;
                bool rain = id(rain_detection).state;
                float wind = id(wind_speed).has_state() ? id(wind_speed).state : 0.0;
                
                uint32_t sleep_ms = 600000; // Default: 10 min
                std::string mode = "Normal";

                // 1. KRITICKÁ BATÉRIA (<20%) -> ECO MÓD
                if (bat < 20.0) {
                   sleep_ms = 1800000; // 30 min
                   mode = "ECO (Low Bat)";
                }
                // 2. BÚRKA (Dážď alebo Vietor > 15km/h) a Batéria > 30% -> STORM MÓD
                else if ((rain || wind > 15.0) && bat > 30.0) {
                   sleep_ms = 120000; // 2 min
                   mode = "STORM (Active)";
                }
                // 3. PLNÁ BATÉRIA (>80%) -> PERFORMANCE MÓD
                else if (bat > 80.0) {
                   sleep_ms = 300000; // 5 min
                   mode = "High Perf";
                }

                ESP_LOGI("deep_sleep", "Rozhodnutie: %s, Spánok: %u ms, Bat: %.1f%%", mode.c_str(), sleep_ms, bat);
                id(deep_sleep_control).set_sleep_duration(sleep_ms);
            
            - deep_sleep.enter: deep_sleep_control

interval:
  # Kontrola spánku každých 30s (ak náhodou skript nedobehol)
  - interval: 30s
    then:
      - script.execute: check_and_enter_deep_sleep
